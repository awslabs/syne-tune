import numpy as np
import pandas

from typing import List, Optional, Union


def get_pareto_optimal(costs: np.ndarray):
    """
    Find the pareto-optimal points
    :param costs: (n_points, m_cost_values) array
    :return: (n_points, 1) indicator if point is on pareto front or not.
    """

    assert type(costs) == np.ndarray
    assert costs.ndim == 2

    # first assume all points are pareto optimal
    is_pareto = np.ones(costs.shape[0], dtype=bool)
    for i, c in enumerate(costs):
        if is_pareto[i]:
            # determine all points that have a smaller cost
            all_with_lower_costs = np.any(costs < c, axis=1)
            keep_on_front = np.logical_and(all_with_lower_costs, is_pareto)
            is_pareto = keep_on_front
            is_pareto[i] = True  # keep self
    return is_pareto


def get_pareto_set(results: pandas.DataFrame, metrics: List[str], mode: Optional[Union[str, List[str]]] = 'min'):
    """
    Returns a subset of the results frame consisting of all Pareto optimal points.
    :param results: pandas.DataFrame Experiment results dataframe generated by the Tuner object
    :param metrics: List that contains all metrics that should be optimized
    :param mode: Defines for each metric whether to maximize or minimize
    :return: DataFrame with Pareto set
    """

    if mode:
        if isinstance(mode, List):
            assert len(mode) == len(metrics), "one mode should be given per metric"
            assert all(
                m in ["min", "max"] for m in mode
            ), "all modes should be 'min' or 'max'."
        else:
            assert mode in ["min", "max"], "``mode`` must be 'min' or 'max'."

    if isinstance(mode, List):
        metric_op = {
            metric: 1 if mode == "min" else -1
            for metric, mode in zip(metrics, mode)
        }
    else:
        if mode == "min":
            metric_op = dict(zip(metrics, [1.0] * len(metrics)))
        elif mode == "max":
            metric_op = dict(zip(metrics, [-1.0] * len(metrics)))

    costs = np.empty((len(results), len(metrics)))

    for i, metric in enumerate(metrics):
        costs[:, i] = metric_op[metric] * results[metric]

    is_pareto = get_pareto_optimal(costs)

    return results[is_pareto]
